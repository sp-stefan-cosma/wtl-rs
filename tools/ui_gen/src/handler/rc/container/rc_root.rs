use std::path::PathBuf;
use std::collections::BTreeMap;
use std::fs::{self,File};
use std::io::Write;
use winapi::WORD;
use regex::Regex;
use super::{Container,ContainerType,Name,util};

pub struct RcRoot {
    root: Container,
    consts: BTreeMap<String,WORD>,
}

impl RcRoot {
	pub fn new()->RcRoot{
		RcRoot{
			root: Container::with_name(Name::root(),ContainerType::Root),
			consts: BTreeMap::new(),
		}
	}

	/// consts from the resouce.h,these consts will be used in ui mod and handler mod
	pub fn set_consts(&mut self,c: BTreeMap<String,WORD>) {
		self.consts = c;
	}

	/// parse dialog using the give text from rc_file
	pub fn parse_dialog(&mut self,id: &str, data: &str){
		let n = Name::dialog(id);
		let mut dlg = Container::with_name(n,ContainerType::Dialog);
		let re_begin = Regex::new(r"\sBEGIN\s").unwrap();
		if let Some(begin_pos) = re_begin.find(data) {
			let ctrl_begin = begin_pos.1;
			dlg.parse_ctrls(&data[ctrl_begin..data.len() - 3]);	//delte "END"
		}
		self.root.add_child(Box::new(dlg));
	}

	/// construct a tree structure as the given path,and return all it's container
	pub fn make_path(&mut self, selected_item_name: &str, mut p: &[String])->Vec<String> {
		//select: IDD_ABOUT_DLG, p: [Root,IDD_MAIN_DLG]
		//println!("direct parent path:{:?}", p);
		// pop "root" first
		assert!(p[0] == "Root");
		p = &p[1..];

		//the selected dlg in listbox,so remove it from rc_root first
		let mut selected_dlg = self.root.delete_child(selected_item_name);
		
		// return children of the selected container
		let ret = selected_dlg.direct_child_container();

		// container where inserted to
		let direct_parent_dlg = self.root.from_path(p).expect("container shold exist");
		direct_parent_dlg.add_child(selected_dlg);
		ret
	}

	/// delete a give path,and return all containers(only dlgs)
	pub fn delete_path(&mut self,p: Vec<String>)->Vec<String> {
		Vec::new()
	}

	/// print the tree structure
	pub fn print(&self) {
		//println!("Root");
		self.root.print(0);
	}
}


impl RcRoot {
	pub fn write_files(&mut self) {
		let mut cur_path = PathBuf::from(".\\ui");
		//if dir exist,delete first
		if let Ok(()) = fs::remove_dir_all(cur_path.as_path().clone()) {
			println!("delete dir ui ok");
		}

		println!("cur path: {:?}", cur_path);
		util::mkdir(&cur_path);
		
		//these files in the root of ui
		self.write_consts_file(cur_path.clone());
		self.write_root_mod_file(cur_path.clone());
		self.write_message_loop_file(cur_path.clone());

		//mod.rs of Root
		let mut child_mod_path = cur_path.clone();
		child_mod_path.push("mod.rs");
		let mut child_mod_file = File::create(child_mod_path.as_path()).unwrap();
		self.root.write_file(&mut child_mod_file, &mut cur_path);

		//default handler save to ui\handler,so all files in ui directory are generated by this tool
		//only user handler save in .\\handler
		//all default bindings write in the same directory
		let mut system_binding_path = PathBuf::from(".\\ui\\handler");
		//if dir exist,delete first
		if let Ok(()) = fs::remove_dir_all(system_binding_path.as_path().clone()) {
			println!("delete dir handler/system ok");
		}

		util::mkdir(&system_binding_path);
		//binding files
		let mut ui_path: Vec<String> = Vec::new();
		self.root.write_binding_file(&mut system_binding_path,&mut ui_path);
	}

	/// write consts to ui\consts.rs
	fn write_consts_file(&self, mut cur_path: PathBuf) {
		cur_path.push("consts.rs");
		//create dir if not exist
		
		let mut f = File::create(cur_path.as_path().clone()).unwrap();
		writeln!(f,"#![allow(dead_code)]").unwrap();
		writeln!(f,"use winapi::WORD;").unwrap();
		for (id,value) in &self.consts {
			writeln!(f,"pub const {}: WORD = {};",id,value).unwrap();
		}
	}

	/// write ui\mod.rs
	fn write_root_mod_file(&self, mut cur_path: PathBuf) {
		cur_path.push("mod.rs");
		let mut f = File::create(cur_path.as_path()).unwrap();
		writeln!(f,"{}",ROOT_MOD_FILE).unwrap();
	}

	/// message loop 
	fn write_message_loop_file(&self, mut cur_path: PathBuf) {
		//const s: &'static str = "use winapi::*;\r\nuse user32::*;\r\n\r\npub struct MessageLoop;\r\n\r\nimpl MessageLoop {\r\n\tpub fn run(){\r\n\t\tlet mut msg = MSG{hwnd:0 as HWND,message:0,wParam:0,lParam:0,time:0,pt:POINT{x:0,y:0}};\r\n\t\tunsafe{\r\n\t\t\twhile GetMessageW( &mut msg, 0 as HWND, 0, 0 ) > 0 {\r\n\t\t\t\tTranslateMessage(&msg);\r\n\t\t\t\tDispatchMessageW(&msg);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}";
		cur_path.push("message_loop.rs");

		let mut f = File::create(cur_path.as_path().clone()).unwrap();
		writeln!(f,"{}",MSG_LOOP_FILE).unwrap();
	}
}

const ROOT_MOD_FILE: &'static str = r"
pub use self::message_loop::MessageLoop;
pub use self::root::Root;
pub use self::consts::*;

mod message_loop;
mod root;
mod sub_root;
pub mod consts;
";

const MSG_LOOP_FILE: &'static str = r"
use winapi::*;
use user32::*;

pub struct MessageLoop;

impl MessageLoop {
	pub fn run(){
		let mut msg = MSG{hwnd:0 as HWND,message:0,wParam:0,lParam:0,time:0,pt:POINT{x:0,y:0}};
		unsafe{
			while GetMessageW( &mut msg, 0 as HWND, 0, 0 ) > 0 { 
				TranslateMessage(&msg); 
				DispatchMessageW(&msg); 
			}
		}
	}
}";
